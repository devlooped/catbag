// <auto-generated />
#region License
// MIT License
// 
// Copyright (c) Daniel Cazzulino
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
#endregion

#nullable enable
using System.Collections.Generic;
using System.Linq;
using System.Dynamic;
using System.Collections;
using System.ComponentModel;

namespace System.Xml.Linq
{
    /// <summary>
    /// Provides the <see cref="AsDynamic"/> extension method for 
    /// <see cref="XElement"/>, allowing read-only dynamic API
    /// access over the underlying XML.
    /// </summary>
    /// <remarks>
    /// After loading an <see cref="XDocument"/> as usual (or an 
    /// <see cref="XElement"/> directly), you can simply access the 
    /// contents using dynamic notation, such as:
    /// <code>
    /// var page = XDocument.Load("page.xhtml").Root.AsDynamic();
    /// foreach (var meta in page.head.meta)
    /// {
    ///     Console.WriteLine($"{meta["name"]}={meta["content"]}");
    /// }
    /// </code>
    /// <para>
    /// Note how dot notation accesses child elements and indexer 
    /// notation is used to access attributes (i.e. &lt;meta name="foo" content="bar" /&ht;). 
    /// For cases where the attribute name is not a valid C# identifier, 
    /// indexer notation will also fallback to attempting to locate a 
    /// child element if an attribute with the same name doesn't exist.
    /// </para>
    /// </remarks>
    [EditorBrowsable(EditorBrowsableState.Never)]
    static partial class AsDynamicExtension
	{
		static readonly Dictionary<Type, Func<string, object>> xmlConverters;

		static AsDynamicExtension()
		{
			xmlConverters = new Dictionary<Type, Func<string, object>>
			{
				{ typeof(Boolean), s => XmlConvert.ToBoolean(s) },
				{ typeof(Byte), s => XmlConvert.ToByte(s) },
				{ typeof(Char), s => XmlConvert.ToChar(s) },
				{ typeof(DateTime), s => XmlConvert.ToDateTime(s, XmlDateTimeSerializationMode.RoundtripKind) },
				{ typeof(DateTimeOffset), s => XmlConvert.ToDateTimeOffset(s) },
				{ typeof(Decimal), s => XmlConvert.ToDecimal(s) },
				{ typeof(Double), s => XmlConvert.ToDouble(s) },
				{ typeof(Guid), s => XmlConvert.ToGuid(s) },
				{ typeof(Int16), s => XmlConvert.ToInt16(s) },
				{ typeof(Int32), s => XmlConvert.ToInt32(s) },
				{ typeof(Int64), s => XmlConvert.ToInt64(s) },
				{ typeof(SByte), s => XmlConvert.ToSByte(s) },
				{ typeof(Single), s => XmlConvert.ToSingle(s) },
				{ typeof(TimeSpan), s => XmlConvert.ToTimeSpan(s) },
				{ typeof(UInt16), s => XmlConvert.ToUInt16(s) },
				{ typeof(UInt32), s => XmlConvert.ToUInt32(s) },
				{ typeof(UInt64), s => XmlConvert.ToUInt64(s) },
			};
		}

		/// <summary>
		/// Converts the element into a dynamic object to use 
		/// dotted and indexer notation for elements and attribtes, 
		/// with built-in support for <see cref="XmlConvert"/> when 
		/// casting the resulting values.
		/// </summary>
		/// <param name="xml" this="true">The element to access using dynamic notation.</param>
		public static dynamic AsDynamic(this XElement xml) => new DynamicXmlElement(xml);

		static bool TryXmlConvert(string value, Type returnType, out object? result)
		{
			if (returnType == typeof(string))
			{
				result = value;
				return true;
			}
			else if (returnType.IsEnum)
			{
				// First try enum try parse:
				if (Enum.IsDefined(returnType, value))
				{
					result = Enum.Parse(returnType, value);
					return true;
				}

				// We know we support all underlying types for enums, 
				// which are all numeric.
				var enumType = Enum.GetUnderlyingType(returnType);
				var rawValue = xmlConverters[enumType].Invoke(value);

				result = Enum.ToObject(returnType, rawValue);
				return true;
			}
			else
			{
				var converter = default(Func<string, object>);
				if (xmlConverters.TryGetValue(returnType, out converter))
				{
					result = converter(value);
					return true;
				}
			}

			result = null;
			return false;
		}

		class DynamicXmlElement : DynamicObject, IEnumerable<XElement>, IEnumerable<DynamicObject>
		{
			readonly XElement xml;

			public DynamicXmlElement(XElement xml) => this.xml = xml;

			public override bool TryGetIndex(GetIndexBinder binder, object[] indexes, out object? result)
			{
				var name = GetNameIndex(indexes);
				var existingAttr = xml.Attribute(name);
				if (existingAttr == null)
				{
					// Try element name.
					var matches = xml.Elements(name);

					// If we have more than one, return the collection.
					if (matches.Skip(1).Any())
					{
						result = new DynamicXmlElements(matches);
					}
					else
					{
						result = matches
							.Select(x => new DynamicXmlElement(x))
							.FirstOrDefault();
					}

					return true;
				}
				else
				{
					result = new DynamicXmlAttribute(existingAttr);
					return true;
				}
			}

			public override bool TrySetIndex(SetIndexBinder binder, object[] indexes, object? value)
			{
                if (value == null)
                    throw new ArgumentNullException(nameof(value));
                
				var name = GetNameIndex(indexes);
				var existingAttr = xml.Attribute(name);
				var existingEl = xml.Element(name);

				var attrValue = value as XAttribute;
				var stringValue = value as string;

				if (existingAttr == null)
				{
					if (existingEl != null)
					{
						existingEl.SetValue(value);
					}
					else
					{
						if (stringValue != null)
							attrValue = new XAttribute(name, value);

						xml.Add(attrValue);
					}
				}
				else
				{
					if (attrValue != null)
						stringValue = attrValue.Value;

                    if (stringValue != null)
					    existingAttr.SetValue(stringValue);
                    else
                        throw new ArgumentException("Value must be a string or XAttribute.");
                }

				return true;
			}

			private XName GetNameIndex(object[] indexes)
			{
				if (indexes.Length != 1)
					throw new NotSupportedException("Attributes can only be accessed using a single index of type string or XName");

				var result = default(XName);
				if (indexes[0] is string)
					result = XName.Get((string)indexes[0]);
				else if (indexes[0] is XName)
					result = (XName)indexes[0];
				else
					throw new NotSupportedException("Attribute index can only be a simple attribute name, an expanded XML name string, or an XName");

				return result;
			}

			public override bool TryGetMember(GetMemberBinder binder, out object? result)
			{
				var matches = xml.Elements().Where(x => x.Name.LocalName.Equals(binder.Name));

				// If we have more than one, return the collection.
				if (matches.Skip(1).Any())
				{
					result = new DynamicXmlElements(matches);
				}
				else
				{
					result = matches
						.Select(x => new DynamicXmlElement(x))
						.FirstOrDefault();
				}

				return true;
			}

			public override bool TryConvert(ConvertBinder binder, out object? result)
			{
				if (binder.ReturnType == typeof(XElement))
				{
					result = xml;
					return true;
				}
                else if (binder.ReturnType.IsAssignableFrom(typeof(IEnumerable)) ||
                    binder.ReturnType.IsAssignableFrom(typeof(IEnumerable<object>)) ||
                    binder.ReturnType.IsAssignableFrom(typeof(object[])) ||
                    binder.ReturnType.IsAssignableFrom(typeof(IEnumerable<DynamicObject>)) ||
                    binder.ReturnType.IsAssignableFrom(typeof(dynamic[])) ||
                    binder.ReturnType.IsAssignableFrom(typeof(DynamicObject[])))
                {
                    result = xml.Elements().Select(el => new DynamicXmlElement(el)).ToArray();
                    return true;
                }
                else if (binder.ReturnType.IsAssignableFrom(typeof(ICollection)) ||
                    binder.ReturnType.IsAssignableFrom(typeof(IList<object>)) ||
                    binder.ReturnType.IsAssignableFrom(typeof(ICollection<object>)) ||
                    binder.ReturnType.IsAssignableFrom(typeof(IReadOnlyList<object>)) ||
                    binder.ReturnType.IsAssignableFrom(typeof(IReadOnlyCollection<object>)) ||
                    binder.ReturnType.IsAssignableFrom(typeof(IList<DynamicObject>)) ||
                    binder.ReturnType.IsAssignableFrom(typeof(ICollection<DynamicObject>)) ||
                    binder.ReturnType.IsAssignableFrom(typeof(IReadOnlyList<DynamicObject>)) ||
                    binder.ReturnType.IsAssignableFrom(typeof(IReadOnlyCollection<DynamicObject>)))
                {
                    result = xml.Elements().Select(el => new DynamicXmlElement(el)).ToList();
                    return true;
                }
                else if (TryXmlConvert(xml.Value, binder.ReturnType, out result))
				{
					return true;
				}

				return base.TryConvert(binder, out result);
			}

			public IEnumerator<XElement> GetEnumerator() => xml.Elements().GetEnumerator();

			IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

			IEnumerator<DynamicObject> IEnumerable<DynamicObject>.GetEnumerator()
                => xml.Elements().Select(el => new DynamicXmlElement(el)).GetEnumerator();
		}

		class DynamicXmlAttribute : DynamicObject
		{
			readonly XAttribute xml;

			public DynamicXmlAttribute(XAttribute xml) => this.xml = xml;

			public override bool TryConvert(ConvertBinder binder, out object? result)
			{
				if (binder.ReturnType == typeof(XAttribute))
				{
					result = xml;
					return true;
				}
				else if (TryXmlConvert(xml.Value, binder.ReturnType, out result))
				{
					return true;
				}

				return base.TryConvert(binder, out result);
			}

			public override string ToString() => xml.Value;
		}

		class DynamicXmlElements : DynamicObject, IEnumerable<XElement>, IEnumerable<DynamicObject>
		{
			readonly List<XElement> elements;

			public DynamicXmlElements(IEnumerable<XElement> elements) => this.elements = elements.ToList();

			public override bool TryConvert(ConvertBinder binder, out object? result)
			{
                if (binder.ReturnType.IsAssignableFrom(typeof(IEnumerable)) ||
                    binder.ReturnType.IsAssignableFrom(typeof(IEnumerable<object>)) ||
                    binder.ReturnType.IsAssignableFrom(typeof(object[])) ||
                    binder.ReturnType.IsAssignableFrom(typeof(IEnumerable<DynamicObject>)) ||
                    binder.ReturnType.IsAssignableFrom(typeof(dynamic[])) ||
                    binder.ReturnType.IsAssignableFrom(typeof(DynamicObject[])))
                {
                    result = elements.Select(el => new DynamicXmlElement(el)).ToArray();
					return true;
				}
                else if (binder.ReturnType.IsAssignableFrom(typeof(ICollection)) ||
                    binder.ReturnType.IsAssignableFrom(typeof(IList<object>)) ||
                    binder.ReturnType.IsAssignableFrom(typeof(ICollection<object>)) ||
                    binder.ReturnType.IsAssignableFrom(typeof(IReadOnlyList<object>)) ||
                    binder.ReturnType.IsAssignableFrom(typeof(IReadOnlyCollection<object>)) ||
                    binder.ReturnType.IsAssignableFrom(typeof(IList<DynamicObject>)) ||
                    binder.ReturnType.IsAssignableFrom(typeof(ICollection<DynamicObject>)) ||
                    binder.ReturnType.IsAssignableFrom(typeof(IReadOnlyList<DynamicObject>)) ||
                    binder.ReturnType.IsAssignableFrom(typeof(IReadOnlyCollection<DynamicObject>)))
                {
                    result = elements.Select(el => new DynamicXmlElement(el)).ToList();
                    return true;
                }

                return base.TryConvert(binder, out result);
			}

			public override bool TryGetIndex(GetIndexBinder binder, object[] indexes, out object? result)
			{
				if (indexes.Length == 1 && indexes[0] is int)
				{
					result = new DynamicXmlElement(this.elements[(int)indexes[0]]);
					return true;
				}

				return base.TryGetIndex(binder, indexes, out result);
			}

			public IEnumerator<XElement> GetEnumerator() => elements.GetEnumerator();

            // Untyped enumeration goes through the dynamic route.
            IEnumerator IEnumerable.GetEnumerator() => ((IEnumerable<DynamicObject>)this).GetEnumerator();

			IEnumerator<DynamicObject> IEnumerable<DynamicObject>.GetEnumerator()
                => elements.Select(el => new DynamicXmlElement(el)).GetEnumerator();
		}
	}
}